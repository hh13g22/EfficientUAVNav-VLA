import os
import json
import time
import shutil
import tempfile
from utils import get_glb_path, is_success, load_posture

# 配置参数

DATASET_ROOT = "/home/testunot/datasets/habitat/IndoorUAV-VLA"
AGENT_ROOT = "/home/testunot/IndoorUAV-Agent"

MAX_INFERENCE_STEPS = 12
SHARED_FOLDER = "/home/testunot/IndoorUAV-Agent/online_eval/vla_eval/shared_folder"
TEST_VLA_FILE = "/home/testunot/IndoorUAV-Agent/online_eval/vla_eval/test_vla.json"
VLA_INS_BASE = os.path.join(DATASET_ROOT, "vla_ins")
POSTURE_BASE = os.path.join(DATASET_ROOT, "without_screenshot")

TRAJECTORY_OUTPUT = os.path.join(SHARED_FOLDER, "trajectories")
CONTROLLER_INPUT = os.path.join(SHARED_FOLDER, "controller_input")
SIM_INPUT_DIR = os.path.join(SHARED_FOLDER, "sim_input")
SIM_OUTPUT_DIR = os.path.join(SHARED_FOLDER, "sim_output")
MODEL_INPUT_DIR = os.path.join(SHARED_FOLDER, "model_input")
MODEL_OUTPUT_DIR = os.path.join(SHARED_FOLDER, "model_output")
INSTRUCTIONS_DIR = os.path.join(SHARED_FOLDER, "instructions")
IMAGE_STORAGE = os.path.join(SHARED_FOLDER, "images")
INDOOR_UAV_BASE = DATASET_ROOT  # set to the same

# 确保目录存在
for dir_path in [CONTROLLER_INPUT, SIM_INPUT_DIR, SIM_OUTPUT_DIR,
                 MODEL_INPUT_DIR, MODEL_OUTPUT_DIR, TRAJECTORY_OUTPUT,
                 INSTRUCTIONS_DIR, IMAGE_STORAGE]:
    os.makedirs(dir_path, exist_ok=True)


# Original file writing and reading implementation was an approximate wait and then read
# Atomic Writing is a race free assertion that signifies that the target file does not exist yet
def atomic_write_json(path, data):
    dir_name = os.path.dirname(path) or "."
    with tempfile.NamedTemporaryFile('w', dir=dir_name, delete=False, suffix='.tmp') as tmp:
        json.dump(data, tmp)
        tmp_path = tmp.name
    os.replace(tmp_path, path)

# Tries to read the a json file to test and report if the file is empty or partially written
def safe_read_json(path):
    try:
        with open(path, 'r') as f:
            return json.load(f)
    except (json.JSONDecodeError, OSError):
        return None

class EpisodeController:
    def __init__(self, episode_key):
        self.episode_key = episode_key
        self.trajectory = []
        self.step_count = 0
        self.success = False
        self.start_coords = None
        self.end_coords = None
        self.glb_path = None
        self.instruction = None
        self.start_image_path = None
        self.terminated = False # Stops double episode termination

        # 解析路径
        path_parts = episode_key.rsplit('/', 1)[0]
        parts = path_parts.strip('/').split('/')
        self.group = parts[0]
        self.scene = parts[1]
        self.traj = parts[2]

    def setup_episode(self):
        """Set the initial state of the new episode"""
        print(f"\n=== Start testing: {self.episode_key} ===")

        # Loading instructions and source
        vla_ins_path = os.path.join(VLA_INS_BASE, self.group, self.scene, self.traj,
                                    os.path.basename(self.episode_key))
        with open(vla_ins_path, 'r', encoding='gbk') as f:
            vla_data = json.load(f)

        self.instruction = vla_data["instruction"]
        source = vla_data["source"]
        start_idx = source[0] - 1
        end_idx = source[1] - 1

        # Get GLB path (GT)
        self.glb_path = get_glb_path(self.group, self.scene)

        # Load posture data (GT)
        posture_path = os.path.join(POSTURE_BASE, self.group, self.scene, self.traj, "posture.json")
        self.start_coords, self.end_coords = load_posture(posture_path, start_idx, end_idx)
        
        # Add starting coordinates to the trajectory
        self.trajectory.append(self.start_coords)

        # Get the starting frame image (new)
        start_frame_number = source[0]  # Starting frame number

        print(f"Start image will be generated by simulator")
        self.start_image_path = None

        # Load reference images (Disabled for saving disk space)
        """
        screenshots_dir = os.path.join(INDOOR_UAV_BASE, self.group, self.scene, self.traj, "screenshots")
        self.start_image_path = os.path.join(screenshots_dir, f"{start_frame_number}.png")

        # Make sure the image exists
        if not os.path.exists(self.start_image_path):
            print(f"Warning: Starting image does not exist: {self.start_image_path}")
            self.start_image_path = None
        """

        # Append the current instruction (including the starting image path).
        self.update_instruction_file()

        # Send starting coordinates to simulator to trigger the first render
        self.send_to_simulator(self.start_coords, True)
        print("Waiting for initial image from simulator...")
        timeout = 30
        start_wait = time.time()
        while self.start_image_path is None:
            if time.time() - start_wait > timeout:
                raise TimeoutError("Simulator did not provide initial image within timeout")
            
            # Check for simulator output
            for file_name in os.listdir(SIM_OUTPUT_DIR):
                if not file_name.endswith('.json'):
                    continue
                
                file_path = os.path.join(SIM_OUTPUT_DIR, file_name)

                """                 
                try:
                    time.sleep(0.1)  # Small delay to ensure file is written
                    with open(file_path, 'r') as f:
                        data = json.load(f)
                    
                    if data.get("episode_key") == self.episode_key:
                        self.start_image_path = data["image_path"]
                        print(f"Received initial image: {self.start_image_path}")
                        os.remove(file_path)
                        break
                except Exception as e:
                    print(f"Error reading sim output: {e}")
                    time.sleep(0.1)
                    continue """

                # Implement smart waiting conditions and double wait time
                try:
                    data = safe_read_json(file_path)
                    if data is None:
                        time.sleep(0.2)
                        continue

                    if data.get("episode_key") == self.episode_key:
                        self.start_image_path = data["image_path"]
                        print(f"Received initial image: {self.start_image_path}")
                        os.remove(file_path)
                        break
                except Exception as e:
                    print(f"Error reading sim output: {e}")
                    time.sleep(0.1)
                    continue

            time.sleep(0.1)
    
        # Now update instruction file with the actual image path
        self.update_instruction_file()
        print(f"Setup complete with start image: {self.start_image_path}")
        
        # send to model to trigger first inference
        self.send_to_model(self.start_image_path, self.start_coords)
        print("Initial image sent to model, waiting for first action...")

    """     
    def update_instruction_file(self):
    # Helper to update the instruction file shared with Model Runner
    instruction_file = os.path.join(INSTRUCTIONS_DIR, "current_instruction.json")
    with open(instruction_file, 'w') as f:
        json.dump({
            "episode_key": self.episode_key,
            "instruction": self.instruction,
            "end_coords": self.end_coords,
            "glb_path": self.glb_path,
            "start_coords": self.start_coords,
            "start_image_path": self.start_image_path # Add starting image path
        }, f) """
       
    # Updated instruction write function that atomically writes files
    def update_instruction_file(self):
        instruction_file = os.path.join(INSTRUCTIONS_DIR, "current_instruction.json")
        atomic_write_json(instruction_file, {
            "episode_key": self.episode_key,
            "instruction": self.instruction,
            "end_coords": self.end_coords,
            "glb_path": self.glb_path,
            "start_coords": self.start_coords,
            "start_image_path": self.start_image_path,
        })  

    def send_to_simulator(self, coords, is_new_scene=False):
        """Send coordinates to the simulator"""
        timestamp = time.time()
        sim_input_file = os.path.join(SIM_INPUT_DIR, f"sim_input_{timestamp}.json")

        """         
        with open(sim_input_file, 'w') as f:
            json.dump({
                "episode_key": self.episode_key,
                "coordinates": coords,
                "glb_path": self.glb_path if is_new_scene else None,
                "is_new_scene": is_new_scene
            }, f) """

        # Instead Atommically write
        atomic_write_json(sim_input_file, {
            "episode_key": self.episode_key,
            "coordinates": coords,
            "glb_path": self.glb_path if is_new_scene else None,
            "is_new_scene": is_new_scene,
        })
        
        print(f"Sent coordinates to simulator: {coords}")

    def send_to_model(self, image_path, coords):
        """Send image and coordinates to model"""
        timestamp = time.time()
        model_input_file = os.path.join(MODEL_INPUT_DIR, f"model_input_{timestamp}.json")


        """         
        with open(model_input_file, 'w') as f:
            json.dump({
                "episode_key": self.episode_key,
                "image_path": image_path,
                "coordinates": coords
            }, f) """
        # Atomic Write to avoid race conditions and JSONDecodeError
        atomic_write_json(model_input_file, {
            "episode_key": self.episode_key,
            "image_path": image_path,
            "coordinates": coords,
        })

        print(f"Sent image to model: {os.path.basename(image_path)}")

    def process_sim_output(self, sim_data):
        """Process simulator output"""
        if sim_data.get("episode_key") != self.episode_key:
            return False
        
        current_coords = sim_data["coordinates"]
        image_path = sim_data["image_path"]
        
        # Skip the initial image (already handled in setup)
        if len(self.trajectory) == 1 and self.step_count == 0:
            print("Skipping initial image (already processed in setup)")
            return False
        
        # Add to trajectory
        self.trajectory.append(current_coords)
        
        # Check success
        self.success = is_success(current_coords, self.end_coords)
        
        if self.success:
            print(f"Success! Reached target in {self.step_count} steps")
            self.terminate_episode()
            return False
        
        if self.step_count >= MAX_INFERENCE_STEPS:
            print(f"Max steps reached ({MAX_INFERENCE_STEPS})")
            self.terminate_episode()
            return False
        
        # Send image to model
        self.send_to_model(image_path, current_coords)
        return True
    

    def process_model_output(self, model_data):
        """Process model output"""
        if model_data.get("episode_key") != self.episode_key:
            return False

        new_coords = model_data["coordinates"]
        self.step_count += 1
        print(f"Reasoning Steps used: {self.step_count}/{MAX_INFERENCE_STEPS} - New coordinates: {new_coords}")

        # Send new coordinates to simulator
        self.send_to_simulator(new_coords)
        return True

    def terminate_episode(self):
        """Terminate the current episode and save the results."""
        if self.terminated: # Check if already terminated
            return
        self.terminated = True
        # Save trajectory
        safe_episode_key = self.episode_key.replace('/', '_').replace(':', '_').replace(' ', '_')
        trajectory_file = os.path.join(TRAJECTORY_OUTPUT, f"{safe_episode_key}.json")

        """         
        with open(trajectory_file, 'w') as f:
            json.dump({
                "episode_key": self.episode_key,
                "success": self.success, # yes if reached goal no if early termination
                "steps": self.step_count, 
                "trajectory": self.trajectory
            }, f, indent=2) """

        # Replace with atomic writes
        atomic_write_json(trajectory_file, {
            "episode_key": self.episode_key,
            "success": self.success,
            "steps": self.step_count,
            "trajectory": self.trajectory,
        })

        print(f"Episode completed! Success: {self.success}, Step Count: {self.step_count}")

        # Send termination signal, received by model and simulator
        terminate_file = os.path.join(SIM_INPUT_DIR, "terminate.json")

        """         
        with open(terminate_file, 'w') as f:
            json.dump({
                "episode_key": self.episode_key,
                "action": "terminate"
            }, f) """

        # Like wise replace with atomic write
        atomic_write_json(terminate_file, {
            "episode_key": self.episode_key,
            "action": "terminate",
        })


class FileMover:
    """The component responsible for moving files between directories"""

    def __init__(self):
        self.active = True

    def move_sim_output_to_model_input(self):
        """Move simulator output to model input: Images, Pose, Coordinates"""
        for file_name in os.listdir(SIM_OUTPUT_DIR):
            if not file_name.endswith('.json'):
                continue
            
            # Get the output path
            src_path = os.path.join(SIM_OUTPUT_DIR, file_name)
            # Renames the file whilst also moving it to denote simulator output
            dst_path = os.path.join(CONTROLLER_INPUT, f"sim_{file_name}")

            try:
                shutil.move(src_path, dst_path)
                print(f"Simulator output moved: {file_name} -> {os.path.basename(dst_path)}")
            except Exception as e:
                print(f"Failed to move file: {str(e)}")

    def move_model_output_to_sim_input(self):
        """Move model output to simulator input: Actions"""
        for file_name in os.listdir(MODEL_OUTPUT_DIR):
            if not file_name.endswith('.json'):
                continue

            src_path = os.path.join(MODEL_OUTPUT_DIR, file_name)
            # Renames file with model_ to denote model output
            dst_path = os.path.join(CONTROLLER_INPUT, f"model_{file_name}")

            try:
                shutil.move(src_path, dst_path)
                print(f"Model output moved: {file_name} -> {os.path.basename(dst_path)}")
            except Exception as e:
                print(f"Failed to move file: {str(e)}")

def clear_shared_folder():

    # Wipe all shared folder subdirs at the start of each run

    dirs_to_clear = [

        CONTROLLER_INPUT, SIM_INPUT_DIR, SIM_OUTPUT_DIR,

        MODEL_INPUT_DIR, MODEL_OUTPUT_DIR,

        INSTRUCTIONS_DIR, IMAGE_STORAGE

    ]

    for dir_path in dirs_to_clear:

        for item in os.listdir(dir_path):

            item_path = os.path.join(dir_path, item)

            if os.path.isfile(item_path):

                os.remove(item_path)

    print("Sharedfolder cleared")
 

def main():
    clear_shared_folder()
    # Load test configuration
    with open(TEST_VLA_FILE, 'r') as f:
        test_vla = json.load(f)

    # Initialize file mover
    file_mover = FileMover()

    # Run all episodes
    results = {}
    episode_keys = list(test_vla.keys())

    for i, episode_key in enumerate(episode_keys):
        print(f"\n{'=' * 40}") # Print line
        print(f"Start testing {i + 1}/{len(episode_keys)}: {episode_key}")

        # Initialize the current episode
        controller = EpisodeController(episode_key)
        controller.setup_episode()

        # Clear directory
        for dir_path in [CONTROLLER_INPUT, SIM_OUTPUT_DIR, MODEL_OUTPUT_DIR]:
            for item in os.listdir(dir_path):
                item_path = os.path.join(dir_path, item)
                if os.path.isfile(item_path):
                    os.remove(item_path)

        # Start Episode
        start_time = time.time()
        while True:
            # Move Files
            file_mover.move_sim_output_to_model_input()
            file_mover.move_model_output_to_sim_input()
            #print(f"Controller input files: {os.listdir(CONTROLLER_INPUT)}") # The problem with this is that it will print [] if there exists nothing in the dir

            # improved implementation
            files = [f for f in os.listdir(CONTROLLER_INPUT) if f.endswith('.json')]
            if files: # only print if there exists 
                print(f"Controller input files: {files}")

            # Handle controller input
            processed = False # Initialise false as no data has been processed
            for file_name in os.listdir(CONTROLLER_INPUT):
                if not file_name.endswith('.json'):
                    continue
                
                # Found a new frame
                file_path = os.path.join(CONTROLLER_INPUT, file_name)
            
                # Process the outputs
                try:
                    with open(file_path, 'r') as f:
                        data = json.load(f)

                    # Handling simulator output give the model img, coordinates
                    if file_name.startswith('sim_'):
                        if controller.process_sim_output(data):
                            processed = True # Flag true

                    # Handling model outputs give simulator new coordinates
                    elif file_name.startswith('model_'):
                        if controller.process_model_output(data):
                            processed = True

                    # Delete processed files
                    os.remove(file_path)

                except Exception as e:
                    print(f"Error processing file {file_name} Error: {str(e)}")
                    continue

            # Check the termination condition
            if controller.success or controller.step_count >= MAX_INFERENCE_STEPS:
                controller.terminate_episode() # Terminate 1
                time.sleep(0.2)
                break # Break out of while loop 

            # Timeout
            if time.time() - start_time > 240:
                print("Episode Time Limit Exceeded")
                controller.terminate_episode() # Terminate 2
                time.sleep(0.2)
                break

            # If no files are being processed, wait a while, for VLA
            if not processed:
                time.sleep(0.1)

        # Record results
        results[episode_key] = {
            "success": controller.success,
            "steps": controller.step_count,
            "difficulty": test_vla[episode_key].get("difficulty", "unknown"),
            "action_type": test_vla[episode_key].get("action_type", [])
        }

    # Save final result
    results_file = os.path.join(TRAJECTORY_OUTPUT, "final_results.json")
    with open(results_file, 'w') as f:
        json.dump(results, f, indent=2)

    print("\nAll Episodes Complete!")


if __name__ == "__main__":

    main()
